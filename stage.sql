
CREATE EXTENSION pgcrypto;

/*

                                                                                                 Table "public.users"
   Column   |            Type             | Collation | Nullable |             Default              | Storage  | Stats target |                                      Description                                      
------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+---------------------------------------------------------------------------------------
 user_id    | integer                     |           | not null | generated by default as identity | plain    |              | 
 email      | character varying(255)      |           | not null |                                  | extended |              | 
 password   | bytea                       |           | not null |                                  | extended |              | Argon2 hashed output
 salt       | bytea                       |           | not null |                                  | extended |              | Unique salt per-user
 created_on | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 last_login | timestamp without time zone |           |          |                                  | plain    |              | 
 inactive   | boolean                     |           | not null | false                            | plain    |              | Allows a user to pseudo-delete their account without our record-books being corrupted
Indexes:
    "users_pkey" PRIMARY KEY, btree (user_id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)
Check constraints:
    "chk_login_created" CHECK (created_on <= last_login)
    "users_password_check" CHECK (octet_length(password) = 64)
    "users_salt_check" CHECK (octet_length(salt) = 32)
Referenced by:
    TABLE "carts" CONSTRAINT "carts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
    TABLE "chefs" CONSTRAINT "chefs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
    TABLE "orders" CONSTRAINT "orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
    TABLE "sessions" CONSTRAINT "sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS users (
  user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR ( 255 ) UNIQUE NOT NULL,
  password BYTEA NOT NULL CHECK (octet_length(password) = 64),
  salt BYTEA NOT NULL CHECK (octet_length(salt) = 32),
  created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_login TIMESTAMP,
  inactive BOOLEAN NOT NULL DEFAULT FALSE,
  CONSTRAINT chk_login_created CHECK (created_on <= last_login) -- sanity-check
  /* TODO payment methods */
  /* TODO shipping & billing */
);

comment on table users is 'All users that can log-in';
comment on column users.password is 'Argon2 hashed output';
comment on column users.salt is 'Unique salt per-user';
comment on column users.inactive is 'Allows a user to pseudo-delete their account without our record-books being corrupted';


/*
Here, during registration, we email the address a link with a unique token,
to verify the email is authentic. Furthermore, in the email with a "click here to complete"
link, we'll also include everything they put in the registration form as url parameters
(pkdf2 encrypting the password first).

                                                          Table "public.pending_registrations"
   Column   |            Type             | Collation | Nullable |                   Default                    | Storage  | Stats target | Description 
------------+-----------------------------+-----------+----------+----------------------------------------------+----------+--------------+-------------
 email      | character varying(255)      |           | not null |                                              | extended |              | 
 auth_token | bytea                       |           | not null | digest(gen_random_bytes(64), 'sha512'::text) | extended |              | 
 expiration | timestamp without time zone |           | not null | (CURRENT_TIMESTAMP + '1 day'::interval)      | plain    |              | 
Indexes:
    "pending_registrations_pkey" PRIMARY KEY, btree (auth_token)
    "pending_registrations_email_key" UNIQUE CONSTRAINT, btree (email)
Check constraints:
    "pending_registrations_auth_token_check" CHECK (octet_length(auth_token) = 64)
Access method: heap


*/
CREATE TABLE IF NOT EXISTS pending_registrations (
  email VARCHAR ( 255 ) UNIQUE NOT NULL, -- Doesn't reference users because it doesn't exist yet.
  auth_token BYTEA PRIMARY KEY CHECK (octet_length(auth_token) = 64)
    DEFAULT digest(gen_random_bytes(64), 'sha512'),
  expiration TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP + INTERVAL '1 day'
);

comment on table pending_registrations is 'Any pending registrations that need to click the email link';

-- TODO call from a cron job
CREATE FUNCTION expire_pending_registrations() RETURNS trigger
  LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM pending_registrations WHERE expiration < NOW();
  RETURN NEW;
END;
$$;

/*
Table of only active pending registrations as a view, to make things easier and less reliant on cron-jobs
to ensure pending registrations are legitimate.

                             View "public.active_pending_registrations"
   Column   |            Type             | Collation | Nullable | Default | Storage  | Description 
------------+-----------------------------+-----------+----------+---------+----------+-------------
 email      | character varying(255)      |           |          |         | extended | 
 auth_token | bytea                       |           |          |         | extended | 
 expiration | timestamp without time zone |           |          |         | plain    | 
View definition:
 SELECT pending_registrations.email,
    pending_registrations.auth_token,
    pending_registrations.expiration
   FROM pending_registrations
  WHERE pending_registrations.expiration >= CURRENT_TIMESTAMP;


*/
CREATE VIEW active_pending_registrations AS
  SELECT * FROM pending_registrations WHERE expiration >= CURRENT_TIMESTAMP;

comment on view active_pending_registrations is 'Any pending registrations that are not expired';

CREATE FUNCTION select_pending_registration(BYTEA) RETURNS VARCHAR
AS 'DELETE FROM pending_registrations WHERE auth_token = $1 AND expiration >= CURRENT_TIMESTAMP RETURNING email;'
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;


/*
Every time a user successfully logs in, we'll issue them a session token that gets kept in a
cookie, and verified every time they check out a page on the website. Every time communication
is valid in a good session, the expiration resets to now + 1 day. Then as a cron job, the
database will prune old data during off hours.

                                                                  Table "public.sessions"
    Column     |            Type             | Collation | Nullable |                   Default                    | Storage  | Stats target | Description 
---------------+-----------------------------+-----------+----------+----------------------------------------------+----------+--------------+-------------
 user_id       | integer                     |           | not null |                                              | plain    |              | 
 session_token | bytea                       |           | not null | digest(gen_random_bytes(64), 'sha512'::text) | extended |              | 
 expiration    | timestamp without time zone |           | not null | (CURRENT_TIMESTAMP + '1 day'::interval)      | plain    |              | 
Indexes:
    "sessions_pkey" PRIMARY KEY, btree (session_token)
Check constraints:
    "sessions_session_token_check" CHECK (octet_length(session_token) = 64)
Foreign-key constraints:
    "sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS sessions (
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT, -- not unique - multiple logged-in users
  session_token BYTEA NOT NULL PRIMARY KEY CHECK (octet_length(session_token) = 64)
    DEFAULT digest(gen_random_bytes(64), 'sha512'),
  expiration TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP + INTERVAL '1 day'
  -- TODO when a user is pseudo-deleted via `inactive`, delete all session rows for that user, logging them out
);

comment on table sessions is 'Any active logged-in users, with their session token and expiration';

-- TODO call from a cron job
CREATE FUNCTION expire_sessions() RETURNS trigger
  LANGUAGE plpgsql
AS $$
BEGIN
  DELETE FROM sessions WHERE expiration < NOW();
  RETURN NEW;
END;
$$;

-- TODO make a selection function that also updates its expiration when a row is found


/*
Table of only active sessions as a view, to make things easier and less reliant on cron-jobs to ensure
sessions are legitimate.

                                     View "public.active_sessions"
    Column     |            Type             | Collation | Nullable | Default | Storage  | Description 
---------------+-----------------------------+-----------+----------+---------+----------+-------------
 user_id       | integer                     |           |          |         | plain    | 
 session_token | bytea                       |           |          |         | extended | 
 expiration    | timestamp without time zone |           |          |         | plain    | 
View definition:
 SELECT sessions.user_id,
    sessions.session_token,
    sessions.expiration
   FROM sessions
  WHERE sessions.expiration >= CURRENT_TIMESTAMP;


*/
CREATE VIEW active_sessions AS
  SELECT * FROM sessions WHERE expiration >= CURRENT_TIMESTAMP;

CREATE FUNCTION get_login_salt(VARCHAR) RETURNS BYTEA
AS 'SELECT salt FROM users WHERE email = $1;'
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;

CREATE FUNCTION login(VARCHAR, BYTEA) RETURNS BYTEA
AS 'INSERT INTO sessions (user_id) SELECT user_id FROM users WHERE email = $1 AND password = $2 RETURNING session_token;'
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE FUNCTION lookup_and_update_session(BYTEA) RETURNS BYTEA
AS 'UPDATE sessions SET session_token = digest(gen_random_bytes(64), ''sha512'') WHERE session_token = $1 RETURNING session_token;'
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;


CREATE TYPE subscription_type AS ENUM ('free', 'premium', 'gold', 'platinum');

/*
A chef is a Local Cooking user that we vet to have the power to create their own menus.

                                                                  Table "public.chefs"
         Column          |            Type             | Collation | Nullable |             Default              | Storage  | Stats target | Description 
-------------------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 user_id                 | integer                     |           | not null |                                  | plain    |              | 
 chef_id                 | integer                     |           | not null | generated by default as identity | plain    |              | 
 public_name             | character varying(255)      |           | not null |                                  | extended |              | 
 profile                 | character varying(1024)     |           |          |                                  | extended |              | 
 enrolled_on             | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 revoked                 | boolean                     |           | not null | false                            | plain    |              | 
 subscription            | subscription_type           |           | not null |                                  | plain    |              | 
 subscription_expiration | timestamp without time zone |           | not null |                                  | plain    |              | 
Indexes:
    "chefs_pkey" PRIMARY KEY, btree (chef_id)
    "chefs_user_id_key" UNIQUE CONSTRAINT, btree (user_id)
Foreign-key constraints:
    "chefs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
Referenced by:
    TABLE "chef_credentials" CONSTRAINT "chef_credentials_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE RESTRICT
    TABLE "menus" CONSTRAINT "menus_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS chefs (
  user_id INT UNIQUE NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  chef_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  public_name VARCHAR ( 255 ) NOT NULL,
  profile VARCHAR ( 1024 ),
  enrolled_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  revoked BOOLEAN NOT NULL DEFAULT FALSE, -- Pseudo-deletion
  subscription subscription_type NOT NULL,
  subscription_expiration TIMESTAMP NOT NULL
  -- FIXME product delivery method
  -- TODO Payment method (same as user?)
);

/*
At Local Cooking, we're going to grow our chef's credentials over time. Each new trend
will require new skills and certifications - for instance, being trained in gluten intolerance,
or peanut allergies, could be a specific trade. Furthermore, we may certify someone as a
vegan cook, which may grant them special interest. Likewise, in the future, chefs may issue
certifications of their own, which they use to vet other chefs and grow their academia.

                                                        Table "public.credentials"
    Column     |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
---------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 credential_id | integer                 |           | not null | generated by default as identity | plain    |              | 
 title         | character varying(255)  |           | not null |                                  | extended |              | 
 description   | character varying(1024) |           | not null |                                  | extended |              | 
Indexes:
    "credentials_pkey" PRIMARY KEY, btree (credential_id)
Referenced by:
    TABLE "chef_credentials" CONSTRAINT "chef_credentials_credential_id_fkey" FOREIGN KEY (credential_id) REFERENCES credentials(credential_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS credentials (
  credential_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
);

/*
Mapping between chefs and their credentials.

                                 Table "public.chef_credentials"
    Column     |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------------+---------+-----------+----------+---------+---------+--------------+-------------
 chef_id       | integer |           | not null |         | plain   |              | 
 credential_id | integer |           | not null |         | plain   |              | 
Indexes:
    "chef_credentials_chef_id_credential_id_key" UNIQUE CONSTRAINT, btree (chef_id, credential_id)
Foreign-key constraints:
    "chef_credentials_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE RESTRICT
    "chef_credentials_credential_id_fkey" FOREIGN KEY (credential_id) REFERENCES credentials(credential_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS chef_credentials (
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE RESTRICT,
  credential_id INT NOT NULL REFERENCES credentials (credential_id) ON DELETE RESTRICT,
  UNIQUE (chef_id, credential_id) -- A chef can't have two of the same credential
);

/*
Menus are the curated options that users can select to purchase orders from chefs.

                                                          Table "public.menus"
   Column    |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
-------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 menu_id     | integer                 |           | not null | generated by default as identity | plain    |              | 
 chef_id     | integer                 |           | not null |                                  | plain    |              | 
 title       | character varying(255)  |           | not null |                                  | extended |              | 
 description | character varying(1024) |           | not null |                                  | extended |              | 
Indexes:
    "menus_pkey" PRIMARY KEY, btree (menu_id)
Foreign-key constraints:
    "menus_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE RESTRICT
Referenced by:
    TABLE "menu_item_mapping" CONSTRAINT "menu_item_mapping_menu_id_fkey" FOREIGN KEY (menu_id) REFERENCES menus(menu_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS menus (
  menu_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
  -- TODO themes
  -- TODO images
);
/* TODO constraints - one menu for free, three for premium, 10 for gold, inf for platinum */

/*
Menu items are the actual products that users can purchase, which may be showcased in one or more
menu.

                                                           Table "public.items"
   Column   |            Type             | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------+-----------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 item_id    | integer                     |           | not null | generated by default as identity | plain   |              | 
 created_on | timestamp without time zone |           |          | CURRENT_TIMESTAMP                | plain   |              | 
Indexes:
    "items_pkey" PRIMARY KEY, btree (item_id)
Referenced by:
    TABLE "carts" CONSTRAINT "carts_item_id_fkey" FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE RESTRICT
    TABLE "item_revisions" CONSTRAINT "item_revisions_item_id_fkey" FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE RESTRICT
    TABLE "menu_item_mapping" CONSTRAINT "menu_item_mapping_item_id_fkey" FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS items (
  item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */

/*
Allows for revisions to be saved over time, that way an order refers to a specific edition of an item,
and not one that was edited after being ordered.

                                                          Table "public.item_revisions"
      Column      |            Type             | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 item_revision_id | integer                     |           | not null | generated by default as identity | plain    |              | 
 item_id          | integer                     |           | not null |                                  | plain    |              | 
 title            | character varying(255)      |           | not null |                                  | extended |              | 
 description      | character varying(1024)     |           | not null |                                  | extended |              | 
 price            | integer                     |           | not null |                                  | plain    |              | 
 appx_order_delay | interval day to hour        |           | not null |                                  | plain    |              | 
 deleted          | boolean                     |           | not null | false                            | plain    |              | 
 edited_on        | timestamp without time zone |           |          | CURRENT_TIMESTAMP                | plain    |              | 
Indexes:
    "item_revisions_pkey" PRIMARY KEY, btree (item_revision_id)
Check constraints:
    "item_revisions_price_check" CHECK (price > 0)
Foreign-key constraints:
    "item_revisions_item_id_fkey" FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE RESTRICT
Referenced by:
    TABLE "carts" CONSTRAINT "carts_unseen_revision_fkey" FOREIGN KEY (unseen_revision) REFERENCES item_revisions(item_revision_id) ON DELETE RESTRICT
    TABLE "order_contents" CONSTRAINT "order_contents_item_revision_id_fkey" FOREIGN KEY (item_revision_id) REFERENCES item_revisions(item_revision_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS item_revisions (
  item_revision_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  item_id INT NOT NULL REFERENCES items (item_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL,
  price INT NOT NULL CHECK (price > 0),
  appx_order_delay INTERVAL DAY TO HOUR NOT NULL,
  deleted BOOLEAN NOT NULL DEFAULT FALSE, -- pseudo-deletion; doesn't actually delete from db for order book
  edited_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  /* TODO images */
  /* FIXME categories like vegan etc. */
);
-- FIXME max number of revisions? Revision spamming?

/*
Many-to-many relationship of the same item going to different menus, and the same menu having different items.

                                            Table "public.menu_item_mapping"
    Column    |  Type   | Collation | Nullable |             Default              | Storage | Stats target | Description 
--------------+---------+-----------+----------+----------------------------------+---------+--------------+-------------
 menu_item_id | integer |           | not null | generated by default as identity | plain   |              | 
 menu_id      | integer |           | not null |                                  | plain   |              | 
 item_id      | integer |           | not null |                                  | plain   |              | 
Indexes:
    "menu_item_mapping_pkey" PRIMARY KEY, btree (menu_item_id)
Foreign-key constraints:
    "menu_item_mapping_item_id_fkey" FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE RESTRICT
    "menu_item_mapping_menu_id_fkey" FOREIGN KEY (menu_id) REFERENCES menus(menu_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS menu_item_mapping (
  menu_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  menu_id INT NOT NULL REFERENCES menus (menu_id) ON DELETE RESTRICT,
  item_id INT NOT NULL REFERENCES items (item_id) ON DELETE RESTRICT
  /* FIXME position of items in menus */
  /* FIXME max number of items per menu */
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */
-- Nothing references this table, rows can be added & deleted freely per the chef's desire.

-- CREATE TABLE IF NOT EXISTS menu_item_ordering (
--   menu_id INT UNIQUE NOT NULL REFERENCES menus (menu_id) ON DELETE CASCADE,
--   menu_item_ids INT[] NOT NULL REFERENCES menu_item_mapping (menu_item_id) ON DELETE PRUNE -- wtf
-- );

/*
The cart for people to file orders

                                                              Table "public.carts"
     Column      |            Type             | Collation | Nullable |             Default              | Storage | Stats target | Description 
-----------------+-----------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 cart_id         | integer                     |           | not null | generated by default as identity | plain   |              | 
 user_id         | integer                     |           | not null |                                  | plain   |              | 
 item_id         | integer                     |           | not null |                                  | plain   |              | 
 unseen_revision | integer                     |           |          |                                  | plain   |              | 
 quantity        | integer                     |           | not null | 1                                | plain   |              | 
 added_on        | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain   |              | 
Indexes:
    "carts_pkey" PRIMARY KEY, btree (cart_id)
    "carts_user_id_item_id_key" UNIQUE CONSTRAINT, btree (user_id, item_id)
Check constraints:
    "carts_quantity_check" CHECK (quantity > 0)
Foreign-key constraints:
    "carts_item_id_fkey" FOREIGN KEY (item_id) REFERENCES items(item_id) ON DELETE RESTRICT
    "carts_unseen_revision_fkey" FOREIGN KEY (unseen_revision) REFERENCES item_revisions(item_revision_id) ON DELETE RESTRICT
    "carts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS carts (
  cart_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  item_id INT NOT NULL REFERENCES items (item_id) ON DELETE RESTRICT, -- menu_item_mapping is used only for views
  unseen_revision INT REFERENCES item_revisions (item_revision_id) ON DELETE RESTRICT, -- when creating a new revision, also set all carts to that revision as well.
  quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
  added_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, item_id) /* increment quantity instead - FIXME can I just update on insert / delete? */
);
-- When a user checks out, their cart rows are deleted - nothing references this table.

/*
Record of all orders, after a user presses "checkout"

                                                           Table "public.orders"
   Column   |            Type             | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------+-----------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 order_id   | integer                     |           | not null | generated by default as identity | plain   |              | 
 user_id    | integer                     |           | not null |                                  | plain   |              | 
 ordered_on | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain   |              | 
Indexes:
    "orders_pkey" PRIMARY KEY, btree (order_id)
Foreign-key constraints:
    "orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
Referenced by:
    TABLE "order_contents" CONSTRAINT "order_contents_order_id_fkey" FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS orders (
  order_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  ordered_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

/*
Each item purchased under a single order (after a user clicks "Checkout").

                                                          Table "public.order_contents"
      Column      |            Type             | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------------+-----------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 order_content_id | integer                     |           | not null | generated by default as identity | plain   |              | 
 order_id         | integer                     |           | not null |                                  | plain   |              | 
 item_revision_id | integer                     |           | not null |                                  | plain   |              | 
 quantity         | integer                     |           | not null |                                  | plain   |              | 
 completed_on     | timestamp without time zone |           |          |                                  | plain   |              | 
 delivered_on     | timestamp without time zone |           |          |                                  | plain   |              | 
Indexes:
    "order_contents_pkey" PRIMARY KEY, btree (order_content_id)
Check constraints:
    "chk_completed_delivered" CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL))
    "order_contents_quantity_check" CHECK (quantity > 0)
Foreign-key constraints:
    "order_contents_item_revision_id_fkey" FOREIGN KEY (item_revision_id) REFERENCES item_revisions(item_revision_id) ON DELETE RESTRICT
    "order_contents_order_id_fkey" FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE RESTRICT
Referenced by:
    TABLE "reviews" CONSTRAINT "reviews_order_content_id_fkey" FOREIGN KEY (order_content_id) REFERENCES order_contents(order_content_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS order_contents (
  order_content_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id INT NOT NULL REFERENCES orders (order_id) ON DELETE RESTRICT,
  item_revision_id INT NOT NULL REFERENCES item_revisions (item_revision_id) ON DELETE RESTRICT,
  quantity INT NOT NULL CHECK (quantity > 0),
  completed_on TIMESTAMP,
  delivered_on TIMESTAMP,
  CONSTRAINT chk_completed_delivered CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL)) /* makes sure it's not delivered before it's complete */
);

/*
Reviews for a specific order's contents.

                                                              Table "public.reviews"
      Column      |            Type             | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 review_id        | integer                     |           | not null | generated by default as identity | plain    |              | 
 order_content_id | integer                     |           | not null |                                  | plain    |              | 
 reviewed_on      | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 title            | character varying(255)      |           | not null |                                  | extended |              | 
 description      | character varying(1024)     |           |          |                                  | extended |              | 
 stars            | numeric(2,1)                |           |          |                                  | main     |              | 
Indexes:
    "reviews_pkey" PRIMARY KEY, btree (review_id)
    "reviews_order_content_id_key" UNIQUE CONSTRAINT, btree (order_content_id)
Check constraints:
    "reviews_stars_check" CHECK (stars >= 1::numeric AND stars <= 5::numeric)
Foreign-key constraints:
    "reviews_order_content_id_fkey" FOREIGN KEY (order_content_id) REFERENCES order_contents(order_content_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS reviews (
  review_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_content_id INT UNIQUE NOT NULL REFERENCES order_contents (order_content_id) ON DELETE RESTRICT, /* Only one review per order content */
  reviewed_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ),
  /* TODO images */
  stars decimal(2,1) CHECK (stars >= 1 AND stars <= 5) /* For aggregates */
);
