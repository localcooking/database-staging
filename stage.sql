
CREATE EXTENSION IF NOT EXISTS pgcrypto;
-- CREATE EXTENSION IF NOT EXISTS timescaledb;

CREATE SCHEMA api;

/*

                                                                                                   Table "api.users"
     Column     |           Type           | Collation | Nullable |             Default              | Storage  | Stats target |                                      Description                                      
----------------+--------------------------+-----------+----------+----------------------------------+----------+--------------+---------------------------------------------------------------------------------------
 user_id        | integer                  |           | not null | generated by default as identity | plain    |              | 
 email          | character varying(255)   |           | not null |                                  | extended |              | 
 password       | bytea                    |           | not null |                                  | extended |              | Argon2 hashed output
 salt           | bytea                    |           | not null |                                  | extended |              | Unique salt per-user
 created_on     | timestamp with time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 last_login     | timestamp with time zone |           |          |                                  | plain    |              | 
 last_active    | timestamp with time zone |           |          |                                  | plain    |              | 
 deactivated_on | timestamp with time zone |           |          |                                  | plain    |              | Allows a user to pseudo-delete their account without our record-books being corrupted
Indexes:
    "users_pkey" PRIMARY KEY, btree (user_id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)
Check constraints:
    "chk_login_created" CHECK (created_on <= last_login)
    "users_password_check" CHECK (octet_length(password) = 64)
    "users_salt_check" CHECK (octet_length(salt) = 32)
Referenced by:
    TABLE "api.carts" CONSTRAINT "carts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
    TABLE "api.chefs" CONSTRAINT "chefs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
    TABLE "api.orders" CONSTRAINT "orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
    TABLE "api.sessions" CONSTRAINT "sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.users (
  user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR ( 255 ) UNIQUE NOT NULL,
  password BYTEA NOT NULL CHECK (octet_length(password) = 64),
  salt BYTEA NOT NULL CHECK (octet_length(salt) = 32),
  created_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_login TIMESTAMPTZ,
  last_active TIMESTAMPTZ,
  deactivated_on TIMESTAMPTZ,
  CONSTRAINT chk_login_created CHECK (created_on <= last_login) -- sanity-check
  /* TODO payment methods */
  /* TODO shipping & billing */
);

-- FIXME use a log of activity & logins

comment on table  api.users is 'All users that can log-in';
comment on column api.users.password is 'Argon2 hashed output';
comment on column api.users.salt is 'Unique salt per-user';
comment on column api.users.deactivated_on is 'Allows a user to pseudo-delete their account without our record-books being corrupted';

-- Deactivate the currently logged-in user identified by their session_token
CREATE OR REPLACE FUNCTION api.session_deactivate_user(session_token_ uuid) RETURNS timestamptz AS
$$
DECLARE
  user_id_ INT;
  deactivated_on_ timestamptz;
BEGIN
  SELECT get_logged_in_user_id(session_token_) INTO user_id_;
  SELECT admin_deactivate_user(user_id_) INTO deactivated_on_;
  RETURN deactivated_on_;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

-- Administratively deactivate a user identified by their user_id
CREATE OR REPLACE FUNCTION api.admin_deactivate_user(user_id_ INT) RETURNS timestamptz AS
$$
DECLARE
  deactivated_on_ timestamptz;
BEGIN
  UPDATE api.users SET deactivated_on = CURRENT_TIMESTAMP
    WHERE user_id = user_id_
    RETURNING deactivated_on INTO deactivated_on_;
  DELETE FROM sessions WHERE user_id = user_id_; -- Revoke sessions
  RETURN deactivated_on_;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

-- Administratively activate a user by their user_id
CREATE OR REPLACE FUNCTION api.admin_activate_user(user_id_ INT) RETURNS INT AS
$$
  UPDATE api.users SET deactivated_on = NULL
  WHERE user_id = user_id_
  RETURNING user_id;
$$
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;

-- Filtered user list which only includes active users.
CREATE VIEW api.active_users AS
  SELECT * FROM api.users WHERE deactivated_on IS NULL;

/*
Here, during registration, we email the address a link with a unique token,
to verify the email is authentic. Furthermore, in the email with a "click here to complete"
link, we'll also include everything they put in the registration form as url parameters
(pkdf2 encrypting the password first).

                                                      Table "api.pending_registrations"
   Column   |           Type           | Collation | Nullable |                Default                | Storage  | Stats target | Description 
------------+--------------------------+-----------+----------+---------------------------------------+----------+--------------+-------------
 email      | character varying(255)   |           | not null |                                       | extended |              | 
 auth_token | uuid                     |           | not null | gen_random_uuid()                     | plain    |              | 
 expiration | timestamp with time zone |           | not null | CURRENT_TIMESTAMP + '1 day'::interval | plain    |              | 
Indexes:
    "pending_registrations_pkey" PRIMARY KEY, btree (auth_token)
    "pending_registrations_email_key" UNIQUE CONSTRAINT, btree (email)
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.pending_registrations (
  email VARCHAR ( 255 ) UNIQUE NOT NULL, -- Doesn't reference users because it doesn't exist yet.
  auth_token uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  expiration TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP + INTERVAL '1 day'
);

comment on table api.pending_registrations is 'Any pending registrations that need to click the email link';

-- TODO call from a cron job
CREATE OR REPLACE FUNCTION api.expire_pending_registrations() RETURNS void AS
$$
  DELETE FROM api.pending_registrations WHERE expiration < CURRENT_TIMESTAMP;
$$
  LANGUAGE SQL
  VOLATILE;

/*
Table of only active pending registrations as a view, to make things easier and less reliant on cron-jobs
to ensure pending registrations are legitimate.

                             View "api.active_pending_registrations"
   Column   |           Type           | Collation | Nullable | Default | Storage  | Description 
------------+--------------------------+-----------+----------+---------+----------+-------------
 email      | character varying(255)   |           |          |         | extended | 
 auth_token | uuid                     |           |          |         | plain    | 
 expiration | timestamp with time zone |           |          |         | plain    | 
View definition:
 SELECT pending_registrations.email,
    pending_registrations.auth_token,
    pending_registrations.expiration
   FROM api.pending_registrations
  WHERE pending_registrations.expiration >= CURRENT_TIMESTAMP;


*/
CREATE VIEW api.active_pending_registrations AS
  SELECT * FROM api.pending_registrations WHERE expiration >= CURRENT_TIMESTAMP;

comment on view api.active_pending_registrations is 'Any pending registrations that are not expired';

CREATE OR REPLACE FUNCTION api.assign_registration(email_ VARCHAR) RETURNS uuid AS
$$
DECLARE
  found_user_ INT;
  returned_session_ uuid;
BEGIN
  SELECT user_id INTO found_user_ FROM api.users WHERE email = email_ AND deactivated_on IS NULL;
  -- Find an active user with the same email
  IF found_user_ IS NULL THEN
    INSERT INTO api.pending_registrations (email) VALUES (email_) RETURNING auth_token INTO returned_session_;
    RETURN returned_session_;
  ELSE
    RAISE 'User with email % already exists', email_;
  END IF;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION api.register(registration_ uuid, email_ VARCHAR, password_ BYTEA, salt_ BYTEA) RETURNS INT AS
$$
DECLARE
  uid INT;
  is_pending_ INT;
  already_exists_ INT;
BEGIN
  -- Make sure the email doesn't already exist
  SELECT 1 INTO already_exists_ FROM api.users
  WHERE email = email_;

  IF already_exists_ = 1 THEN
    RAISE 'email % aready registered', email_;
  ELSE
    -- Ensure a valid pending registration exists
    SELECT 1 INTO is_pending_ FROM api.pending_registrations
      WHERE email = email_
        AND auth_token = registration_
        AND expiration >= CURRENT_TIMESTAMP;

    IF is_pending_ = 1 THEN
      -- delete it
      DELETE FROM api.pending_registrations
      WHERE auth_token = registration_
      AND expiration >= CURRENT_TIMESTAMP
      AND email = email_;

      -- insert the info into the user's column
      INSERT INTO api.users (email, password, salt)
      VALUES (email_, password_, salt_)
      RETURNING user_id INTO uid;
      RETURN uid;
    ELSE
      RAISE 'Pending registration not found: %', registration_;
    END IF;
  END IF;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

/*
Every time a user successfully logs in, we'll issue them a session token that gets kept in a
cookie, and verified every time they check out a page on the website. Every time communication
is valid in a good session, the expiration resets to now + 1 day. Then as a cron job, the
database will prune old data during off hours.

                                                              Table "api.sessions"
    Column     |           Type           | Collation | Nullable |                Default                | Storage | Stats target | Description 
---------------+--------------------------+-----------+----------+---------------------------------------+---------+--------------+-------------
 user_id       | integer                  |           | not null |                                       | plain   |              | 
 session_token | uuid                     |           | not null | gen_random_uuid()                     | plain   |              | 
 expiration    | timestamp with time zone |           | not null | CURRENT_TIMESTAMP + '1 day'::interval | plain   |              | 
Indexes:
    "sessions_pkey" PRIMARY KEY, btree (session_token)
Foreign-key constraints:
    "sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.sessions (
  user_id INT NOT NULL REFERENCES api.users (user_id) ON DELETE RESTRICT, -- not unique - multiple logged-in users
  session_token uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  expiration TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP + INTERVAL '1 day'
  -- TODO when a user is pseudo-deleted via `inactive`, delete all session rows for that user, logging them out
);

comment on table api.sessions is 'Any active logged-in users, with their session token and expiration';

-- SELECT create_hypertable('sessions', 'expiration'); -- FIXME


-- TODO call from a cron job
CREATE OR REPLACE FUNCTION api.expire_sessions() RETURNS void AS
$$
  DELETE FROM api.sessions WHERE expiration < CURRENT_TIMESTAMP;
$$
  LANGUAGE SQL
  VOLATILE;

-- TODO make a selection function that also updates its expiration when a row is found


/*
Table of only active sessions as a view, to make things easier and less reliant on cron-jobs to ensure
sessions are legitimate.

                                    View "api.active_sessions"
    Column     |           Type           | Collation | Nullable | Default | Storage | Description 
---------------+--------------------------+-----------+----------+---------+---------+-------------
 user_id       | integer                  |           |          |         | plain   | 
 session_token | uuid                     |           |          |         | plain   | 
 expiration    | timestamp with time zone |           |          |         | plain   | 
View definition:
 SELECT sessions.user_id,
    sessions.session_token,
    sessions.expiration
   FROM api.sessions
  WHERE sessions.expiration >= CURRENT_TIMESTAMP;


*/
CREATE VIEW api.active_sessions AS
  SELECT * FROM api.sessions WHERE expiration >= CURRENT_TIMESTAMP;

CREATE OR REPLACE FUNCTION api.get_login_salt(email_ VARCHAR) RETURNS BYTEA AS
$$
  SELECT salt FROM api.users WHERE email = email_;
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;

-- FIXME raise when session doesn't exist?
CREATE OR REPLACE FUNCTION api.get_logged_in_user_id(session_token_ uuid) RETURNS INT AS
$$
  SELECT user_id FROM api.sessions WHERE session_token = session_token_;
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION api.login(email_ VARCHAR, password_ BYTEA) RETURNS uuid AS
$$
DECLARE
  -- user_id_ INT;
  -- deactivated_on_ timestamptz;
  correct_creds RECORD;
  active_session uuid;
BEGIN
  SELECT INTO correct_creds user_id, deactivated_on FROM api.users
    WHERE email = email_ AND password = password_;
  IF correct_creds.deactivated_on IS NOT NULL THEN
    RAISE 'User has been deactivated on %', correct_creds.deactivated_on;
  ELSE
    UPDATE api.users SET last_login = CURRENT_TIMESTAMP, last_active = CURRENT_TIMESTAMP
      WHERE user_id = correct_creds.user_id; -- update last login
    INSERT INTO api.sessions (user_id) VALUES (correct_creds.user_id)
      RETURNING session_token INTO active_session; -- insert session
    RETURN active_session;
  END IF;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

-- Should be done last in any authenticated transaction
CREATE OR REPLACE FUNCTION api.touch_session(session_token_ uuid) RETURNS uuid AS
$$
DECLARE
  user_id_ INT;
  active_session uuid;
BEGIN
  SELECT get_logged_in_user_id(session_token_) INTO user_id_; -- find logged-in user
  UPDATE api.users SET last_active = CURRENT_TIMESTAMP WHERE user_id = user_id_; -- update last active
  UPDATE api.sessions SET session_token = gen_random_uuid()
    WHERE session_token = session_token_ AND user_id = user_id_
    RETURNING session_token INTO active_session;
  RETURN active_session;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION api.logout(session_token_ uuid) RETURNS INT AS
$$
  DELETE FROM api.sessions WHERE session_token = session_token_ RETURNING user_id;
$$
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;


-- TODO access log?

CREATE TYPE subscription_type AS ENUM ('free', 'premium', 'gold', 'platinum');

/*
A chef is a Local Cooking user that we vet to have the power to create their own menus.

                                                                  Table "api.chefs"
         Column          |           Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
-------------------------+--------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 user_id                 | integer                  |           | not null |                                  | plain    |              | 
 chef_id                 | integer                  |           | not null | generated by default as identity | plain    |              | 
 public_name             | character varying(255)   |           | not null |                                  | extended |              | 
 profile                 | character varying(1024)  |           |          |                                  | extended |              | 
 enrolled_on             | timestamp with time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 revoked_on              | timestamp with time zone |           |          |                                  | plain    |              | 
 subscription            | subscription_type        |           | not null |                                  | plain    |              | 
 subscription_expiration | timestamp with time zone |           | not null |                                  | plain    |              | 
Indexes:
    "chefs_pkey" PRIMARY KEY, btree (chef_id)
    "chefs_user_id_key" UNIQUE CONSTRAINT, btree (user_id)
Foreign-key constraints:
    "chefs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
Referenced by:
    TABLE "api.chef_credentials" CONSTRAINT "chef_credentials_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES api.chefs(chef_id) ON DELETE RESTRICT
    TABLE "api.menus" CONSTRAINT "menus_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES api.chefs(chef_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.chefs (
  user_id INT UNIQUE NOT NULL REFERENCES api.users (user_id) ON DELETE RESTRICT,
  chef_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  public_name VARCHAR ( 255 ) NOT NULL,
  profile VARCHAR ( 1024 ),
  enrolled_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  revoked_on TIMESTAMPTZ, -- Pseudo-deletion
  subscription subscription_type NOT NULL,
  subscription_expiration TIMESTAMPTZ NOT NULL
  -- FIXME product delivery method
  -- TODO Payment method (same as user?)
  -- TODO chef rating?
);


CREATE OR REPLACE FUNCTION api.admin_enroll(user_id_ INT,
                                            public_name_ VARCHAR,
                                            subscription_ subscription_type,
                                            subscription_expiration_ TIMESTAMPTZ) RETURNS INT AS
$$
  INSERT INTO api.chefs (user_id, public_name, subscription, subscription_expiration)
  VALUES (user_id_, public_name_, subscription_, subscription_expiration_) RETURNING chef_id;
$$
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION api.admin_disenroll(chef_id_ INT) RETURNS void AS
$$
BEGIN
  -- revoke chef
  UPDATE api.chefs SET revoked_on = CURRENT_TIMESTAMP WHERE chef_id = chef_id_;
  -- delete all the chef's items
  WITH chefs_items AS (
    SELECT items.item_id AS item_id
      FROM api.menu_item_mapping
          INNER JOIN api.menus
              ON api.menu_item_mapping.menu_id = api.menus.menu_id
          INNER JOIN api.items
              ON api.menu_item_mapping.item_id = api.items.item_id
      WHERE menus.chef_id = chef_id_
  )
  UPDATE api.items SET deleted_on = CURRENT_TIMESTAMP FROM chefs_items
  WHERE items.item_id = chefs_items.item_id;

END;
$$
  LANGUAGE plpgsql
  VOLATILE;

/*
At Local Cooking, we're going to grow our chef's credentials over time. Each new trend
will require new skills and certifications - for instance, being trained in gluten intolerance,
or peanut allergies, could be a specific trade. Furthermore, we may certify someone as a
vegan cook, which may grant them special interest. Likewise, in the future, chefs may issue
certifications of their own, which they use to vet other chefs and grow their academia.

                                                          Table "api.credentials"
    Column     |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
---------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 credential_id | integer                 |           | not null | generated by default as identity | plain    |              | 
 title         | character varying(255)  |           | not null |                                  | extended |              | 
 description   | character varying(1024) |           | not null |                                  | extended |              | 
Indexes:
    "credentials_pkey" PRIMARY KEY, btree (credential_id)
Referenced by:
    TABLE "api.chef_credentials" CONSTRAINT "chef_credentials_credential_id_fkey" FOREIGN KEY (credential_id) REFERENCES api.credentials(credential_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.credentials (
  credential_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
);

/*
Mapping between chefs and their credentials.

                                  Table "api.chef_credentials"
    Column     |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------------+---------+-----------+----------+---------+---------+--------------+-------------
 chef_id       | integer |           | not null |         | plain   |              | 
 credential_id | integer |           | not null |         | plain   |              | 
Indexes:
    "chef_credentials_chef_id_credential_id_key" UNIQUE CONSTRAINT, btree (chef_id, credential_id)
Foreign-key constraints:
    "chef_credentials_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES api.chefs(chef_id) ON DELETE RESTRICT
    "chef_credentials_credential_id_fkey" FOREIGN KEY (credential_id) REFERENCES api.credentials(credential_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.chef_credentials (
  chef_id INT NOT NULL REFERENCES api.chefs (chef_id) ON DELETE RESTRICT,
  credential_id INT NOT NULL REFERENCES api.credentials (credential_id) ON DELETE RESTRICT,
  UNIQUE (chef_id, credential_id) -- A chef can't have two of the same credential
);

-- TODO need to add creds, remove / delete them, and also menus, items, etc.

CREATE OR REPLACE FUNCTION api.get_chef_credentials(chef_id_ INT) RETURNS record AS
$$
  SELECT credentials.credential_id, credentials.title, credentials.description
  AS credential_id, title, description
    FROM api.chef_credentials
         INNER JOIN api.credentials
             ON api.chef_credentials.credential_id = api.credentials.credential_id
    WHERE api.chef_credentials.chef_id = chef_id_;
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;


CREATE OR REPLACE FUNCTION api.validate_chef_session(session_token_ uuid) RETURNS INT AS
$$
DECLARE
  user_id_ INT;
  chef_id_ INT;
BEGIN
  SELECT api.get_logged_in_user_id(session_token_) INTO user_id_;
  SELECT INTO chef_id_ chef_id FROM api.chefs WHERE user_id = user_id_; -- FIXME raise when not found?
  RETURN chef_id_;
END;
$$
  LANGUAGE plpgsql
  STABLE
  RETURNS NULL ON NULL INPUT;

/*
Menus are the curated options that users can select to purchase orders from chefs.

                                                            Table "api.menus"
   Column    |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
-------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 menu_id     | integer                 |           | not null | generated by default as identity | plain    |              | 
 chef_id     | integer                 |           | not null |                                  | plain    |              | 
 title       | character varying(255)  |           | not null |                                  | extended |              | 
 description | character varying(1024) |           | not null |                                  | extended |              | 
Indexes:
    "menus_pkey" PRIMARY KEY, btree (menu_id)
Foreign-key constraints:
    "menus_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES api.chefs(chef_id) ON DELETE RESTRICT
Referenced by:
    TABLE "api.menu_item_mapping" CONSTRAINT "menu_item_mapping_menu_id_fkey" FOREIGN KEY (menu_id) REFERENCES api.menus(menu_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.menus (
  menu_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chef_id INT NOT NULL REFERENCES api.chefs (chef_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
  -- TODO themes
  -- TODO images
);
/* TODO constraints - one menu for free, three for premium, 10 for gold, inf for platinum */


CREATE OR REPLACE FUNCTION api.create_menu(session_token_ uuid, title_ VARCHAR, description_ VARCHAR) RETURNS INT AS
$$
DECLARE
  chef_id_ INT;
  menu_id_ INT;
BEGIN
  SELECT api.validate_chef_session(session_token_) INTO chef_id_;
  SELECT api.admin_create_menu(chef_id_, title_, description_) INTO menu_id_;
  RETURN menu_id_;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;


-- FIXME "system" vs. "admin" verbiage
CREATE OR REPLACE FUNCTION api.admin_create_menu(chef_id_ INT, title_ VARCHAR, description_ VARCHAR) RETURNS INT AS
$$
  INSERT INTO api.menus (chef_id, title, description)
  VALUES (chef_id_, title_, description_)
         RETURNING menu_id;
$$
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;

/*
Menu items are the actual products that users can purchase, which may be showcased in one or more
menu.

                                                           Table "api.items"
   Column   |           Type           | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------+--------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 item_id    | integer                  |           | not null | generated by default as identity | plain   |              | 
 deleted_on | timestamp with time zone |           |          |                                  | plain   |              | 
 created_on | timestamp with time zone |           |          | CURRENT_TIMESTAMP                | plain   |              | 
 ratings    | integer                  |           | not null | 0                                | plain   |              | 
 rating     | numeric                  |           |          |                                  | main    |              | 
Indexes:
    "items_pkey" PRIMARY KEY, btree (item_id)
Check constraints:
    "items_rating_check" CHECK (rating >= 1::numeric AND rating <= 5::numeric)
Referenced by:
    TABLE "api.carts" CONSTRAINT "carts_item_id_fkey" FOREIGN KEY (item_id) REFERENCES api.items(item_id) ON DELETE RESTRICT
    TABLE "api.item_revisions" CONSTRAINT "item_revisions_item_id_fkey" FOREIGN KEY (item_id) REFERENCES api.items(item_id) ON DELETE RESTRICT
    TABLE "api.menu_item_mapping" CONSTRAINT "menu_item_mapping_item_id_fkey" FOREIGN KEY (item_id) REFERENCES api.items(item_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.items (
  item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  deleted_on TIMESTAMPTZ, -- pseudo-deletion; doesn't actually delete from db for order book
  created_on TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  ratings INT NOT NULL DEFAULT 0,
  rating decimal CHECK (rating >= 1 AND rating <= 5) -- accumulated ratings, to not waste computation
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */

/*
Allows for revisions to be saved over time, that way an order refers to a specific edition of an item,
and not one that was edited after being ordered.

                                                          Table "api.item_revisions"
      Column      |           Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------------+--------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 item_revision_id | integer                  |           | not null | generated by default as identity | plain    |              | 
 item_id          | integer                  |           | not null |                                  | plain    |              | 
 title            | character varying(255)   |           | not null |                                  | extended |              | 
 description      | character varying(1024)  |           | not null |                                  | extended |              | 
 price            | integer                  |           | not null |                                  | plain    |              | 
 appx_order_delay | interval day to hour     |           | not null |                                  | plain    |              | 
 edited_on        | timestamp with time zone |           |          | CURRENT_TIMESTAMP                | plain    |              | 
Indexes:
    "item_revisions_pkey" PRIMARY KEY, btree (item_revision_id)
Check constraints:
    "item_revisions_price_check" CHECK (price > 0)
Foreign-key constraints:
    "item_revisions_item_id_fkey" FOREIGN KEY (item_id) REFERENCES api.items(item_id) ON DELETE RESTRICT
Referenced by:
    TABLE "api.carts" CONSTRAINT "carts_unseen_revision_fkey" FOREIGN KEY (unseen_revision) REFERENCES api.item_revisions(item_revision_id) ON DELETE RESTRICT
    TABLE "api.order_contents" CONSTRAINT "order_contents_item_revision_id_fkey" FOREIGN KEY (item_revision_id) REFERENCES api.item_revisions(item_revision_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.item_revisions (
  item_revision_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  item_id INT NOT NULL REFERENCES api.items (item_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL,
  price INT NOT NULL CHECK (price > 0),
  appx_order_delay INTERVAL DAY TO HOUR NOT NULL,
  edited_on TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
  /* TODO images */
  /* FIXME categories like vegan etc. */
);
-- FIXME max number of revisions? Revision spamming?

/*
A simple sub-table where each item has it's latest revision information
attached.

                                View "api.latest_active_item_revisions"
      Column      |           Type           | Collation | Nullable | Default | Storage  | Description 
------------------+--------------------------+-----------+----------+---------+----------+-------------
 item_id          | integer                  |           |          |         | plain    | 
 created_on       | timestamp with time zone |           |          |         | plain    | 
 item_revision_id | integer                  |           |          |         | plain    | 
 title            | character varying(255)   |           |          |         | extended | 
 description      | character varying(1024)  |           |          |         | extended | 
 price            | integer                  |           |          |         | plain    | 
 appx_order_delay | interval day to hour     |           |          |         | plain    | 
 edited_on        | timestamp with time zone |           |          |         | plain    | 
View definition:
 SELECT items.item_id,
    items.created_on,
    latest_revision.item_revision_id,
    latest_revision.title,
    latest_revision.description,
    latest_revision.price,
    latest_revision.appx_order_delay,
    latest_revision.edited_on
   FROM api.items
     JOIN ( SELECT item_revisions.item_revision_id,
            item_revisions.item_id,
            item_revisions.title,
            item_revisions.description,
            item_revisions.price,
            item_revisions.appx_order_delay,
            max(item_revisions.edited_on) AS edited_on
           FROM api.item_revisions
          GROUP BY item_revisions.item_revision_id) latest_revision ON latest_revision.item_id = items.item_id
  WHERE items.deleted_on IS NULL;


*/
CREATE VIEW api.latest_active_item_revisions AS
  SELECT items.item_id,
         items.created_on,
         latest_revision.item_revision_id,
         latest_revision.title,
         latest_revision.description,
         latest_revision.price,
         latest_revision.appx_order_delay,
         latest_revision.edited_on
    FROM api.items
         JOIN (SELECT item_revisions.item_revision_id,
                      item_revisions.item_id,
                      item_revisions.title,
                      item_revisions.description,
                      item_revisions.price,
                      item_revisions.appx_order_delay,
                      MAX(item_revisions.edited_on) AS edited_on
                FROM api.item_revisions
                GROUP BY api.item_revisions.item_revision_id) latest_revision
                ON latest_revision.item_id = items.item_id
    WHERE api.items.deleted_on IS NULL;

/*
Many-to-many relationship of the same item going to different menus, and the same menu having different items.

                                                Table "api.menu_item_mapping"
      Column       |  Type   | Collation | Nullable |             Default              | Storage | Stats target | Description 
-------------------+---------+-----------+----------+----------------------------------+---------+--------------+-------------
 menu_item_id      | integer |           | not null | generated by default as identity | plain   |              | 
 menu_id           | integer |           | not null |                                  | plain   |              | 
 item_id           | integer |           | not null |                                  | plain   |              | 
 absolute_position | integer |           | not null |                                  | plain   |              | 
Indexes:
    "menu_item_mapping_pkey" PRIMARY KEY, btree (menu_item_id)
Foreign-key constraints:
    "menu_item_mapping_item_id_fkey" FOREIGN KEY (item_id) REFERENCES api.items(item_id) ON DELETE RESTRICT
    "menu_item_mapping_menu_id_fkey" FOREIGN KEY (menu_id) REFERENCES api.menus(menu_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.menu_item_mapping (
  menu_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  menu_id INT NOT NULL REFERENCES api.menus (menu_id) ON DELETE RESTRICT,
  item_id INT NOT NULL REFERENCES api.items (item_id) ON DELETE RESTRICT,
  absolute_position INT NOT NULL
  /* FIXME max number of items per menu */
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */
-- Nothing references this table, rows can be added & deleted freely per the chef's desire.

-- CREATE TABLE IF NOT EXISTS menu_item_ordering (
--   menu_id INT UNIQUE NOT NULL REFERENCES menus (menu_id) ON DELETE CASCADE,
--   menu_item_ids INT[] NOT NULL REFERENCES menu_item_mapping (menu_item_id) ON DELETE PRUNE -- wtf
-- );

-- TODO should I also get the latest version?
CREATE OR REPLACE FUNCTION api.get_menu_items(menu_id_ INT) RETURNS record AS
$$
  SELECT api.items.item_id, api.items.deleted_on, api.items.created_on
  AS item_id, deleted_on, created_on
    FROM api.menu_item_mapping
         INNER JOIN api.items
             ON api.menu_item_mapping.item_id = api.items.item_id
    WHERE api.menu_item_mapping.menu_id = menu_id_
    ORDER BY api.menu_item_mapping.absolute_position ASC;
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;

/*
The cart for people to file orders

                                                              Table "api.carts"
     Column      |           Type           | Collation | Nullable |             Default              | Storage | Stats target | Description 
-----------------+--------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 cart_id         | integer                  |           | not null | generated by default as identity | plain   |              | 
 user_id         | integer                  |           | not null |                                  | plain   |              | 
 item_id         | integer                  |           | not null |                                  | plain   |              | 
 unseen_revision | integer                  |           |          |                                  | plain   |              | 
 quantity        | integer                  |           | not null | 1                                | plain   |              | 
 added_on        | timestamp with time zone |           | not null | CURRENT_TIMESTAMP                | plain   |              | 
Indexes:
    "carts_pkey" PRIMARY KEY, btree (cart_id)
    "carts_user_id_item_id_key" UNIQUE CONSTRAINT, btree (user_id, item_id)
Check constraints:
    "carts_quantity_check" CHECK (quantity > 0)
Foreign-key constraints:
    "carts_item_id_fkey" FOREIGN KEY (item_id) REFERENCES api.items(item_id) ON DELETE RESTRICT
    "carts_unseen_revision_fkey" FOREIGN KEY (unseen_revision) REFERENCES api.item_revisions(item_revision_id) ON DELETE RESTRICT
    "carts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.carts (
  cart_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INT NOT NULL REFERENCES api.users (user_id) ON DELETE RESTRICT,
  item_id INT NOT NULL REFERENCES api.items (item_id) ON DELETE RESTRICT, -- menu_item_mapping is used only for views
  unseen_revision INT REFERENCES api.item_revisions (item_revision_id) ON DELETE RESTRICT, -- when creating a new revision, also set all carts to that revision as well.
  quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
  added_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, item_id) /* increment quantity instead - FIXME can I just update on insert / delete? */
);
-- When a user checks out, their cart rows are deleted - nothing references this table.

CREATE OR REPLACE FUNCTION api.get_cart(user_id_ INT) RETURNS record AS
$$
  SELECT carts.cart_id, carts.item_id, carts.unseen_revision, carts.quantity, carts.added_on
  AS cart_id, item_id, unseen_revision, quantity, added_on
  FROM api.carts
  WHERE user_id = user_id_
  ORDER BY added_on DESC; -- TODO pagination?
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;

/*
Record of all orders, after a user presses "checkout"

                                                           Table "api.orders"
   Column   |           Type           | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------+--------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 order_id   | integer                  |           | not null | generated by default as identity | plain   |              | 
 user_id    | integer                  |           | not null |                                  | plain   |              | 
 ordered_on | timestamp with time zone |           | not null | CURRENT_TIMESTAMP                | plain   |              | 
Indexes:
    "orders_pkey" PRIMARY KEY, btree (order_id)
Foreign-key constraints:
    "orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES api.users(user_id) ON DELETE RESTRICT
Referenced by:
    TABLE "api.order_contents" CONSTRAINT "order_contents_order_id_fkey" FOREIGN KEY (order_id) REFERENCES api.orders(order_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.orders (
  order_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INT NOT NULL REFERENCES api.users (user_id) ON DELETE RESTRICT,
  ordered_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);

/*
Each item purchased under a single order (after a user clicks "Checkout").

                                                          Table "api.order_contents"
      Column      |           Type           | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------------+--------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 order_content_id | integer                  |           | not null | generated by default as identity | plain   |              | 
 order_id         | integer                  |           | not null |                                  | plain   |              | 
 item_revision_id | integer                  |           | not null |                                  | plain   |              | 
 quantity         | integer                  |           | not null |                                  | plain   |              | 
 completed_on     | timestamp with time zone |           |          |                                  | plain   |              | 
 delivered_on     | timestamp with time zone |           |          |                                  | plain   |              | 
Indexes:
    "order_contents_pkey" PRIMARY KEY, btree (order_content_id)
Check constraints:
    "chk_completed_delivered" CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL))
    "order_contents_quantity_check" CHECK (quantity > 0)
Foreign-key constraints:
    "order_contents_item_revision_id_fkey" FOREIGN KEY (item_revision_id) REFERENCES api.item_revisions(item_revision_id) ON DELETE RESTRICT
    "order_contents_order_id_fkey" FOREIGN KEY (order_id) REFERENCES api.orders(order_id) ON DELETE RESTRICT
Referenced by:
    TABLE "api.reviews" CONSTRAINT "reviews_order_content_id_fkey" FOREIGN KEY (order_content_id) REFERENCES api.order_contents(order_content_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.order_contents (
  order_content_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id INT NOT NULL REFERENCES api.orders (order_id) ON DELETE RESTRICT,
  item_revision_id INT NOT NULL REFERENCES api.item_revisions (item_revision_id) ON DELETE RESTRICT,
  quantity INT NOT NULL CHECK (quantity > 0),
  completed_on TIMESTAMPTZ,
  delivered_on TIMESTAMPTZ,
  CONSTRAINT chk_completed_delivered CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL)) /* makes sure it's not delivered before it's complete */
);

/*
Reviews for a specific order's contents.

                                                              Table "api.reviews"
      Column      |           Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------------+--------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 review_id        | integer                  |           | not null | generated by default as identity | plain    |              | 
 order_content_id | integer                  |           | not null |                                  | plain    |              | 
 reviewed_on      | timestamp with time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 title            | character varying(255)   |           | not null |                                  | extended |              | 
 description      | character varying(1024)  |           | not null |                                  | extended |              | 
 stars            | numeric(2,1)             |           |          |                                  | main     |              | 
Indexes:
    "reviews_pkey" PRIMARY KEY, btree (review_id)
    "reviews_order_content_id_key" UNIQUE CONSTRAINT, btree (order_content_id)
Check constraints:
    "reviews_stars_check" CHECK (stars >= 1::numeric AND stars <= 5::numeric)
Foreign-key constraints:
    "reviews_order_content_id_fkey" FOREIGN KEY (order_content_id) REFERENCES api.order_contents(order_content_id) ON DELETE RESTRICT
Access method: heap


*/
CREATE TABLE IF NOT EXISTS api.reviews (
  review_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_content_id INT UNIQUE NOT NULL REFERENCES api.order_contents (order_content_id) ON DELETE RESTRICT, /* Only one review per order content */
  reviewed_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL,
  /* TODO images */
  stars decimal(2,1) CHECK (stars >= 1 AND stars <= 5) /* For aggregates */
);


CREATE OR REPLACE FUNCTION api.review(order_content_id_ INT, title_ VARCHAR, description_ VARCHAR, stars_ decimal) RETURNS INT AS
$$
DECLARE
  ratings_ INT;
  rating_ decimal;
  item_id_ INT;
  returned_rating INT;
BEGIN
  -- find the previous item's ratings
  SELECT items.ratings, items.rating, items.item_id INTO ratings_, rating_, item_id_
    FROM api.order_contents
         JOIN api.item_revisions
                ON order_contents.item_revision_id = item_revisions.item_revision_id
         JOIN api.items
                ON item_revisions.item_id = items.item_id
    WHERE order_contents.order_content_id = order_content_id_;
  -- update the accumulated rating
  UPDATE api.items SET ratings = ratings_ + 1, rating = ((ratings_ * rating_) + stars_) / (ratings_ + 1)
    WHERE items.item_id = item_id_;
  -- insert the review
  INSERT INTO api.reviews (order_content_id, title, description, stars)
    VALUES (order_content_id_, title_, description_, stars_)
           RETURNING review_id INTO returned_rating;
  RETURN returned_rating;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;
