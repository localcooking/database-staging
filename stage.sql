/*

localcooking_20210601=# \d+ users
                                                            Table "public.users"
   Column   |            Type             | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 user_id    | integer                     |           | not null | generated by default as identity | plain    |              | 
 email      | character varying(255)      |           | not null |                                  | extended |              | 
 password   | character varying(255)      |           | not null |                                  | extended |              | 
 created_on | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 last_login | timestamp without time zone |           |          |                                  | plain    |              | 
Indexes:
    "users_pkey" PRIMARY KEY, btree (user_id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)
Check constraints:
    "chk_login_created" CHECK (created_on <= last_login)
Referenced by:
    TABLE "carts" CONSTRAINT "carts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
    TABLE "chefs" CONSTRAINT "chefs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
    TABLE "orders" CONSTRAINT "orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
    TABLE "sessions" CONSTRAINT "sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
Access method: heap

 */

CREATE TABLE IF NOT EXISTS users (
  user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR ( 255 ) UNIQUE NOT NULL,
  password VARCHAR ( 255 ) NOT NULL,
  created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_login TIMESTAMP,
  CONSTRAINT chk_login_created CHECK (created_on <= last_login) /* sanity-check */
  /* TODO payment methods */
);


/*
Here, during registration, we email the address a link with a unique token,
to verify the email is authentic. Furthermore, in the email with a "click here to complete"
link, we'll also include everything they put in the registration form as url parameters
(pkdf2 encrypting the password first).

localcooking_20210601=# \d+ pending_registrations
                                     Table "public.pending_registrations"
   Column   |          Type          | Collation | Nullable | Default | Storage  | Stats target | Description 
------------+------------------------+-----------+----------+---------+----------+--------------+-------------
 email      | character varying(255) |           | not null |         | extended |              | 
 auth_token | character varying(255) |           | not null |         | extended |              | 
Indexes:
    "pending_registrations_pkey" PRIMARY KEY, btree (auth_token)
    "pending_registrations_email_key" UNIQUE CONSTRAINT, btree (email)
Access method: heap

*/
CREATE TABLE IF NOT EXISTS pending_registrations (
  email VARCHAR ( 255 ) UNIQUE NOT NULL, /* Doesn't reference users because it doesn't exist yet. */
  auth_token VARCHAR ( 255 ) PRIMARY KEY
);

/*
Every time a user successfully logs in, we'll issue them a session token that gets kept in a
cookie, and verified every time they check out a page on the website. Every time communication
is valid in a good session, the expiration resets to now + 1 day. Then as a cron job, the
database will prune old data during off hours.

localcooking_20210601=# \d+ sessions
                                                               Table "public.sessions"
    Column     |            Type             | Collation | Nullable |                 Default                 | Storage  | Stats target | Description 
---------------+-----------------------------+-----------+----------+-----------------------------------------+----------+--------------+-------------
 user_id       | integer                     |           | not null |                                         | plain    |              | 
 session_token | character varying(255)      |           | not null |                                         | extended |              | 
 expiration    | timestamp without time zone |           | not null | (CURRENT_TIMESTAMP + '1 day'::interval) | plain    |              | 
Indexes:
    "sessions_pkey" PRIMARY KEY, btree (session_token)
Foreign-key constraints:
    "sessions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS sessions (
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE CASCADE, /* not unique - multiple logged-in users */
  session_token VARCHAR ( 255 ) PRIMARY KEY,
  expiration TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP + INTERVAL '1 day'
);

CREATE TYPE subscription_type AS ENUM ('free', 'premium', 'gold', 'platinum');

/*
A chef is a Local Cooking user that we vet to have the power to create their own menus.

localcooking_20210601=# \d+ chefs
                                                                  Table "public.chefs"
         Column          |            Type             | Collation | Nullable |             Default              | Storage  | Stats target | Description 
-------------------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 user_id                 | integer                     |           | not null |                                  | plain    |              | 
 chef_id                 | integer                     |           | not null | generated by default as identity | plain    |              | 
 public_name             | character varying(255)      |           | not null |                                  | extended |              | 
 profile                 | character varying(1024)     |           |          |                                  | extended |              | 
 enrolled_on             | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 subscription            | subscription_type           |           | not null |                                  | plain    |              | 
 subscription_expiration | timestamp without time zone |           | not null |                                  | plain    |              | 
Indexes:
    "chefs_pkey" PRIMARY KEY, btree (chef_id)
    "chefs_user_id_key" UNIQUE CONSTRAINT, btree (user_id)
Foreign-key constraints:
    "chefs_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
Referenced by:
    TABLE "chef_credentials" CONSTRAINT "chef_credentials_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE CASCADE
    TABLE "menus" CONSTRAINT "menus_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS chefs (
  user_id INT UNIQUE NOT NULL REFERENCES users (user_id) ON DELETE CASCADE,
  chef_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  public_name VARCHAR ( 255 ) NOT NULL,
  profile VARCHAR ( 1024 ),
  enrolled_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  subscription subscription_type NOT NULL,
  subscription_expiration TIMESTAMP NOT NULL
  /* FIXME product delivery method */
  /* TODO Payment method (same as user?) */
);

/*
At Local Cooking, we're going to grow our chef's credentials over time. Each new trend
will require new skills and certifications - for instance, being trained in gluten intolerance,
or peanut allergies, could be a specific trade. Furthermore, we may certify someone as a
vegan cook, which may grant them special interest. Likewise, in the future, chefs may issue
certifications of their own, which they use to vet other chefs and grow their academia.

localcooking_20210601=# \d+ credentials
                                                        Table "public.credentials"
    Column     |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
---------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 credential_id | integer                 |           | not null | generated by default as identity | plain    |              | 
 title         | character varying(255)  |           | not null |                                  | extended |              | 
 description   | character varying(1024) |           | not null |                                  | extended |              | 
Indexes:
    "credentials_pkey" PRIMARY KEY, btree (credential_id)
Referenced by:
    TABLE "chef_credentials" CONSTRAINT "chef_credentials_credential_id_fkey" FOREIGN KEY (credential_id) REFERENCES credentials(credential_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS credentials (
  credential_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
);

/*
Mapping between chefs and their credentials.

localcooking_20210601=# \d+ chef_credentials
                                 Table "public.chef_credentials"
    Column     |  Type   | Collation | Nullable | Default | Storage | Stats target | Description 
---------------+---------+-----------+----------+---------+---------+--------------+-------------
 chef_id       | integer |           | not null |         | plain   |              | 
 credential_id | integer |           | not null |         | plain   |              | 
Indexes:
    "chef_credentials_chef_id_credential_id_key" UNIQUE CONSTRAINT, btree (chef_id, credential_id)
Foreign-key constraints:
    "chef_credentials_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE CASCADE
    "chef_credentials_credential_id_fkey" FOREIGN KEY (credential_id) REFERENCES credentials(credential_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS chef_credentials (
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE CASCADE,
  credential_id INT NOT NULL REFERENCES credentials (credential_id) ON DELETE CASCADE,
  UNIQUE (chef_id, credential_id) /*A chef can't have two of the same credential*/
);

/*
Menus are the curated options that users can select to purchase orders from chefs.

localcooking_20210601=# \d+ menus
                                                          Table "public.menus"
   Column    |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
-------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 menu_id     | integer                 |           | not null | generated by default as identity | plain    |              | 
 chef_id     | integer                 |           | not null |                                  | plain    |              | 
 title       | character varying(255)  |           | not null |                                  | extended |              | 
 description | character varying(1024) |           | not null |                                  | extended |              | 
Indexes:
    "menus_pkey" PRIMARY KEY, btree (menu_id)
Foreign-key constraints:
    "menus_chef_id_fkey" FOREIGN KEY (chef_id) REFERENCES chefs(chef_id) ON DELETE CASCADE
Referenced by:
    TABLE "menu_item_mapping" CONSTRAINT "menu_item_mapping_menu_id_fkey" FOREIGN KEY (menu_id) REFERENCES menus(menu_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS menus (
  menu_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE CASCADE, /* Should I delete all menus? What if they want to come back? */
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
  /* TODO themes */
  /* TODO images */
);
/* TODO constraints - one menu for free, three for premium, 10 for gold, inf for platinum */

/*
Menu items are the actual products that users can purchase, which may be showcased in one or more
menu.

localcooking_20210601=# \d+ menu_items
                                                          Table "public.menu_items"
      Column      |          Type           | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------------+-------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 item_id          | integer                 |           | not null | generated by default as identity | plain    |              | 
 title            | character varying(255)  |           | not null |                                  | extended |              | 
 description      | character varying(1024) |           | not null |                                  | extended |              | 
 price            | integer                 |           | not null |                                  | plain    |              | 
 appx_order_delay | interval day to hour    |           | not null |                                  | plain    |              | 
Indexes:
    "menu_items_pkey" PRIMARY KEY, btree (item_id)
Check constraints:
    "menu_items_price_check" CHECK (price > 0)
Referenced by:
    TABLE "carts" CONSTRAINT "carts_item_id_fkey" FOREIGN KEY (item_id) REFERENCES menu_items(item_id) ON DELETE CASCADE
    TABLE "menu_item_mapping" CONSTRAINT "menu_item_mapping_item_id_fkey" FOREIGN KEY (item_id) REFERENCES menu_items(item_id) ON DELETE CASCADE
    TABLE "order_contents" CONSTRAINT "order_contents_item_id_fkey" FOREIGN KEY (item_id) REFERENCES menu_items(item_id) ON DELETE RESTRICT
Access method: heap

*/
CREATE TABLE IF NOT EXISTS menu_items (
  item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL,
  price INT NOT NULL CHECK (price > 0), /* stored as cents */
  appx_order_delay INTERVAL DAY TO HOUR NOT NULL
  /* TODO images */
  /* FIXME categories like vegan etc. */
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */

/*
Many-to-many relationship of the same item going to different menus, and the same menu having different items.

localcooking_20210601=# \d+ menu_item_mapping
                                            Table "public.menu_item_mapping"
    Column    |  Type   | Collation | Nullable |             Default              | Storage | Stats target | Description 
--------------+---------+-----------+----------+----------------------------------+---------+--------------+-------------
 menu_item_id | integer |           | not null | generated by default as identity | plain   |              | 
 menu_id      | integer |           | not null |                                  | plain   |              | 
 item_id      | integer |           | not null |                                  | plain   |              | 
Indexes:
    "menu_item_mapping_pkey" PRIMARY KEY, btree (menu_item_id)
Foreign-key constraints:
    "menu_item_mapping_item_id_fkey" FOREIGN KEY (item_id) REFERENCES menu_items(item_id) ON DELETE CASCADE
    "menu_item_mapping_menu_id_fkey" FOREIGN KEY (menu_id) REFERENCES menus(menu_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS menu_item_mapping (
  menu_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  menu_id INT NOT NULL REFERENCES menus (menu_id) ON DELETE CASCADE,
  item_id INT NOT NULL REFERENCES menu_items (item_id) ON DELETE CASCADE
  /* FIXME position of items in menus */
  /* FIXME max number of items per menu */
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */

-- CREATE TABLE IF NOT EXISTS menu_item_ordering (
--   menu_id INT UNIQUE NOT NULL REFERENCES menus (menu_id) ON DELETE CASCADE,
--   menu_item_ids INT[] NOT NULL REFERENCES menu_item_mapping (menu_item_id) ON DELETE PRUNE -- wtf
-- );

/*
The cart for people to file orders

localcooking_20210601=# \d+ carts
                                                   Table "public.carts"
  Column  |            Type             | Collation | Nullable |      Default      | Storage | Stats target | Description 
----------+-----------------------------+-----------+----------+-------------------+---------+--------------+-------------
 user_id  | integer                     |           | not null |                   | plain   |              | 
 item_id  | integer                     |           | not null |                   | plain   |              | 
 quantity | integer                     |           | not null | 1                 | plain   |              | 
 added_on | timestamp without time zone |           | not null | CURRENT_TIMESTAMP | plain   |              | 
Indexes:
    "carts_user_id_item_id_key" UNIQUE CONSTRAINT, btree (user_id, item_id)
Check constraints:
    "carts_quantity_check" CHECK (quantity > 0)
Foreign-key constraints:
    "carts_item_id_fkey" FOREIGN KEY (item_id) REFERENCES menu_items(item_id) ON DELETE CASCADE
    "carts_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
Access method: heap

*/
CREATE TABLE IF NOT EXISTS carts (
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE CASCADE,
  item_id INT NOT NULL REFERENCES menu_items (item_id) ON DELETE CASCADE, /* menu_item_mapping is used only for views */
  quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
  added_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, item_id) /* increment quantity instead - FIXME can I just update on insert / delete? */
);

/*
Record of all orders, after a user presses "checkout"

localcooking_20210601=# \d+ orders
                                                           Table "public.orders"
   Column   |            Type             | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------+-----------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 order_id   | integer                     |           | not null | generated by default as identity | plain   |              | 
 user_id    | integer                     |           | not null |                                  | plain   |              | 
 ordered_on | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain   |              | 
Indexes:
    "orders_pkey" PRIMARY KEY, btree (order_id)
Foreign-key constraints:
    "orders_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE RESTRICT
Referenced by:
    TABLE "order_contents" CONSTRAINT "order_contents_order_id_fkey" FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE RESTRICT
Access method: heap

*/
CREATE TABLE IF NOT EXISTS orders (
  order_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT, /* FIXME Should deletion of a user account delete our order books ??? */
  ordered_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

/*
Each item purchased under a single order (after a user clicks "Checkout").

localcooking_20210601=# \d+ order_contents
                                                          Table "public.order_contents"
      Column      |            Type             | Collation | Nullable |             Default              | Storage | Stats target | Description 
------------------+-----------------------------+-----------+----------+----------------------------------+---------+--------------+-------------
 order_content_id | integer                     |           | not null | generated by default as identity | plain   |              | 
 order_id         | integer                     |           | not null |                                  | plain   |              | 
 item_id          | integer                     |           | not null |                                  | plain   |              | 
 quantity         | integer                     |           | not null |                                  | plain   |              | 
 completed_on     | timestamp without time zone |           |          |                                  | plain   |              | 
 delivered_on     | timestamp without time zone |           |          |                                  | plain   |              | 
Indexes:
    "order_contents_pkey" PRIMARY KEY, btree (order_content_id)
Check constraints:
    "chk_completed_delivered" CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL))
    "order_contents_quantity_check" CHECK (quantity > 0)
Foreign-key constraints:
    "order_contents_item_id_fkey" FOREIGN KEY (item_id) REFERENCES menu_items(item_id) ON DELETE RESTRICT
    "order_contents_order_id_fkey" FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE RESTRICT
Referenced by:
    TABLE "reviews" CONSTRAINT "reviews_order_content_id_fkey" FOREIGN KEY (order_content_id) REFERENCES order_contents(order_content_id) ON DELETE RESTRICT
Access method: heap

*/
CREATE TABLE IF NOT EXISTS order_contents (
  order_content_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id INT NOT NULL REFERENCES orders (order_id) ON DELETE RESTRICT, /* FIXME should the order book be deletable? */
  item_id INT NOT NULL REFERENCES menu_items (item_id) ON DELETE RESTRICT, /* FIXME should items being deleted remove an order from the order book? */
  quantity INT NOT NULL CHECK (quantity > 0),
  completed_on TIMESTAMP,
  delivered_on TIMESTAMP,
  CONSTRAINT chk_completed_delivered CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL)) /* makes sure it's not delivered before it's complete */
);

/*
Reviews for a specific order's contents.

localcooking_20210601=# \d+ reviews
                                                              Table "public.reviews"
      Column      |            Type             | Collation | Nullable |             Default              | Storage  | Stats target | Description 
------------------+-----------------------------+-----------+----------+----------------------------------+----------+--------------+-------------
 review_id        | integer                     |           | not null | generated by default as identity | plain    |              | 
 order_content_id | integer                     |           | not null |                                  | plain    |              | 
 reviewed_on      | timestamp without time zone |           | not null | CURRENT_TIMESTAMP                | plain    |              | 
 title            | character varying(255)      |           | not null |                                  | extended |              | 
 description      | character varying(1024)     |           |          |                                  | extended |              | 
 stars            | numeric(2,1)                |           |          |                                  | main     |              | 
Indexes:
    "reviews_pkey" PRIMARY KEY, btree (review_id)
    "reviews_order_content_id_key" UNIQUE CONSTRAINT, btree (order_content_id)
Check constraints:
    "reviews_stars_check" CHECK (stars >= 1::numeric AND stars <= 5::numeric)
Foreign-key constraints:
    "reviews_order_content_id_fkey" FOREIGN KEY (order_content_id) REFERENCES order_contents(order_content_id) ON DELETE RESTRICT
Access method: heap

*/
CREATE TABLE IF NOT EXISTS reviews (
  review_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_content_id INT UNIQUE NOT NULL REFERENCES order_contents (order_content_id) ON DELETE RESTRICT, /* Only one review per order content */
  reviewed_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ),
  /* TODO images */
  stars decimal(2,1) CHECK (stars >= 1 AND stars <= 5) /* For aggregates */
);
