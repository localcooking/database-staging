/*

--{{ users }}

*/
CREATE TABLE IF NOT EXISTS users (
  user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR ( 255 ) UNIQUE NOT NULL,
  password BYTEA NOT NULL CHECK (octet_length(password) = 64),
  salt BYTEA NOT NULL CHECK (octet_length(salt) = 32),
  created_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_login TIMESTAMPTZ,
  last_active TIMESTAMPTZ,
  deactivated_on TIMESTAMPTZ,
  CONSTRAINT chk_login_created CHECK (created_on <= last_login) -- sanity-check
  /* TODO payment methods */
  /* TODO shipping & billing */
);

comment on table users is 'All users that can log-in';
comment on column users.password is 'Argon2 hashed output';
comment on column users.salt is 'Unique salt per-user';
comment on column users.deactivated_on is 'Allows a user to pseudo-delete their account without our record-books being corrupted';

CREATE OR REPLACE FUNCTION session_deactivate_user(session_token_ uuid) RETURNS timestamptz AS
$$
DECLARE
  user_id_ INT;
  deactivated_on_ timestamptz;
BEGIN
  SELECT get_logged_in_user_id(session_token_) INTO user_id_;
  SELECT admin_deactivate_user(user_id_) INTO deactivated_on_;
  RETURN deactivated_on_;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION admin_deactivate_user(user_id_ INT) RETURNS timestamptz AS
$$
DECLARE
  deactivated_on_ timestamptz;
BEGIN
  UPDATE users SET deactivated_on = CURRENT_TIMESTAMP
    WHERE user_id = user_id_
    RETURNING deactivated_on INTO deactivated_on_;
  DELETE FROM sessions WHERE user_id = user_id_; -- Revoke sessions
  RETURN deactivated_on_;
END;
$$
  LANGUAGE plpgsql
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION admin_activate_user(user_id_ INT) RETURNS INT AS
$$
  UPDATE users SET deactivated_on = NULL
  WHERE user_id = user_id_
  RETURNING user_id;
$$
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE VIEW active_users AS
  SELECT * FROM users WHERE deactivated_on IS NULL;
