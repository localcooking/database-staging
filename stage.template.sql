--{{ users pendingRegistrations sessions chefs credentials chefCredentials menus items itemRevisions menuItemMapping carts orders orderContents reviews }}

/*

--{{ users }}

*/
CREATE TABLE IF NOT EXISTS users (
  user_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR ( 255 ) UNIQUE NOT NULL,
  password VARCHAR ( 255 ) NOT NULL,
  created_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  last_login TIMESTAMP,
  inactive BOOLEAN NOT NULL DEFAULT FALSE, -- Allows for pseudo-deletion, without destroying historic data for record keeping
  CONSTRAINT chk_login_created CHECK (created_on <= last_login) /* sanity-check */
  /* TODO payment methods */
  /* TODO shipping & billing */
);


/*
Here, during registration, we email the address a link with a unique token,
to verify the email is authentic. Furthermore, in the email with a "click here to complete"
link, we'll also include everything they put in the registration form as url parameters
(pkdf2 encrypting the password first).

--{{ pendingRegistrations }}

*/
CREATE TABLE IF NOT EXISTS pending_registrations (
  email VARCHAR ( 255 ) UNIQUE NOT NULL, /* Doesn't reference users because it doesn't exist yet. */
  auth_token VARCHAR ( 255 ) PRIMARY KEY
);

/*
Every time a user successfully logs in, we'll issue them a session token that gets kept in a
cookie, and verified every time they check out a page on the website. Every time communication
is valid in a good session, the expiration resets to now + 1 day. Then as a cron job, the
database will prune old data during off hours.

--{{ sessions }}

*/
CREATE TABLE IF NOT EXISTS sessions (
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT, /* not unique - multiple logged-in users */
  session_token VARCHAR ( 255 ) PRIMARY KEY,
  expiration TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP + INTERVAL '1 day'
  -- FIXME when a user is pseudo-deleted via `inactive`, delete all session rows for that user, logging them out
);

CREATE TYPE subscription_type AS ENUM ('free', 'premium', 'gold', 'platinum');

/*
A chef is a Local Cooking user that we vet to have the power to create their own menus.

--{{ chefs }}

*/
CREATE TABLE IF NOT EXISTS chefs (
  user_id INT UNIQUE NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  chef_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  public_name VARCHAR ( 255 ) NOT NULL,
  profile VARCHAR ( 1024 ),
  enrolled_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  revoked BOOLEAN NOT NULL DEFAULT FALSE, -- Pseudo-deletion
  subscription subscription_type NOT NULL,
  subscription_expiration TIMESTAMP NOT NULL
  /* FIXME product delivery method */
  /* TODO Payment method (same as user?) */
);

/*
At Local Cooking, we're going to grow our chef's credentials over time. Each new trend
will require new skills and certifications - for instance, being trained in gluten intolerance,
or peanut allergies, could be a specific trade. Furthermore, we may certify someone as a
vegan cook, which may grant them special interest. Likewise, in the future, chefs may issue
certifications of their own, which they use to vet other chefs and grow their academia.

--{{ credentials }}

*/
CREATE TABLE IF NOT EXISTS credentials (
  credential_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
);

/*
Mapping between chefs and their credentials.

--{{ chefCredentials }}

*/
CREATE TABLE IF NOT EXISTS chef_credentials (
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE RESTRICT,
  credential_id INT NOT NULL REFERENCES credentials (credential_id) ON DELETE RESTRICT,
  UNIQUE (chef_id, credential_id) /*A chef can't have two of the same credential*/
);

/*
Menus are the curated options that users can select to purchase orders from chefs.

--{{ menus }}

*/
CREATE TABLE IF NOT EXISTS menus (
  menu_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
  /* TODO themes */
  /* TODO images */
);
/* TODO constraints - one menu for free, three for premium, 10 for gold, inf for platinum */

/*
Menu items are the actual products that users can purchase, which may be showcased in one or more
menu.

--{{ items }}

*/
CREATE TABLE IF NOT EXISTS items (
  item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */

/*
Allows for revisions to be saved over time, that way an order refers to a specific edition of an item,
and not one that was edited after being ordered.

--{{ itemRevisions }}

*/
CREATE TABLE IF NOT EXISTS item_revisions (
  item_revision_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  item_id INT NOT NULL REFERENCES items (item_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL,
  price INT NOT NULL CHECK (price > 0),
  appx_order_delay INTERVAL DAY TO HOUR NOT NULL,
  deleted BOOLEAN NOT NULL DEFAULT FALSE, -- pseudo-deletion; doesn't actually delete from db for order book
  edited_on TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  /* TODO images */
  /* FIXME categories like vegan etc. */
);

/*
Many-to-many relationship of the same item going to different menus, and the same menu having different items.

--{{ menuItemMapping }}

*/
CREATE TABLE IF NOT EXISTS menu_item_mapping (
  menu_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  menu_id INT NOT NULL REFERENCES menus (menu_id) ON DELETE RESTRICT,
  item_id INT NOT NULL REFERENCES items (item_id) ON DELETE RESTRICT
  /* FIXME position of items in menus */
  /* FIXME max number of items per menu */
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */
-- Nothing references this table, rows can be added & deleted freely per the chef's desire.

-- CREATE TABLE IF NOT EXISTS menu_item_ordering (
--   menu_id INT UNIQUE NOT NULL REFERENCES menus (menu_id) ON DELETE CASCADE,
--   menu_item_ids INT[] NOT NULL REFERENCES menu_item_mapping (menu_item_id) ON DELETE PRUNE -- wtf
-- );

/*
The cart for people to file orders

--{{ carts }}

*/
CREATE TABLE IF NOT EXISTS carts (
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  item_revision_id INT NOT NULL REFERENCES item_revisions (item_revision_id) ON DELETE RESTRICT, /* menu_item_mapping is used only for views FIXME notify when out-of-date? */
  quantity INT NOT NULL DEFAULT 1 CHECK (quantity > 0),
  added_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE (user_id, item_revision_id) /* increment quantity instead - FIXME can I just update on insert / delete? */
);
-- When a user checks out, their cart rows are deleted - nothing references this table.
-- FIXME follow amazon's model - carts just refer the item, and when a new revision is published, just notify
-- the subscriber.

/*
Record of all orders, after a user presses "checkout"

--{{ orders }}

*/
CREATE TABLE IF NOT EXISTS orders (
  order_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id INT NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  ordered_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

/*
Each item purchased under a single order (after a user clicks "Checkout").

--{{ orderContents }}

*/
CREATE TABLE IF NOT EXISTS order_contents (
  order_content_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id INT NOT NULL REFERENCES orders (order_id) ON DELETE RESTRICT,
  item_revision_id INT NOT NULL REFERENCES item_revisions (item_revision_id) ON DELETE RESTRICT,
  quantity INT NOT NULL CHECK (quantity > 0),
  completed_on TIMESTAMP,
  delivered_on TIMESTAMP,
  CONSTRAINT chk_completed_delivered CHECK (NOT (delivered_on IS NOT NULL AND completed_on IS NULL)) /* makes sure it's not delivered before it's complete */
);

/*
Reviews for a specific order's contents.

--{{ reviews }}

*/
CREATE TABLE IF NOT EXISTS reviews (
  review_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_content_id INT UNIQUE NOT NULL REFERENCES order_contents (order_content_id) ON DELETE RESTRICT, /* Only one review per order content */
  reviewed_on TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ),
  /* TODO images */
  stars decimal(2,1) CHECK (stars >= 1 AND stars <= 5) /* For aggregates */
);
