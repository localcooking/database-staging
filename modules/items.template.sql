/*
Menu items are the actual products that users can purchase, which may be showcased in one or more
menu.

--{{ items }}

*/
CREATE TABLE IF NOT EXISTS api.items (
  item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  deleted_on TIMESTAMPTZ, -- pseudo-deletion; doesn't actually delete from db for order book
  created_on TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
  ratings INT NOT NULL DEFAULT 0,
  rating decimal CHECK (rating >= 1 AND rating <= 5) -- accumulated ratings, to not waste computation
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */

GRANT SELECT ON api.items TO anon;

/*
Allows for revisions to be saved over time, that way an order refers to a specific edition of an item,
and not one that was edited after being ordered.

--{{ itemRevisions }}

*/
CREATE TABLE IF NOT EXISTS api.item_revisions (
  item_revision_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  item_id INT NOT NULL REFERENCES api.items (item_id) ON DELETE RESTRICT,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL,
  price INT NOT NULL CHECK (price > 0),
  appx_order_delay INTERVAL DAY TO HOUR NOT NULL,
  edited_on TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
  /* TODO images */
  /* FIXME categories like vegan etc. */
);
-- FIXME max number of revisions? Revision spamming?

GRANT SELECT ON api.item_revisions TO moderator;

/*
A simple sub-table where each item has it's latest revision information
attached.

--{{ latestActiveItemRevisions }}

*/
CREATE VIEW api.latest_active_item_revisions AS
  SELECT items.item_id,
         items.created_on,
         latest_revision.item_revision_id,
         latest_revision.title,
         latest_revision.description,
         latest_revision.price,
         latest_revision.appx_order_delay,
         latest_revision.edited_on
    FROM api.items
         JOIN (SELECT item_revisions.item_revision_id,
                      item_revisions.item_id,
                      item_revisions.title,
                      item_revisions.description,
                      item_revisions.price,
                      item_revisions.appx_order_delay,
                      MAX(item_revisions.edited_on) AS edited_on
                FROM api.item_revisions
                GROUP BY api.item_revisions.item_revision_id) latest_revision
                ON latest_revision.item_id = items.item_id
    WHERE api.items.deleted_on IS NULL;

GRANT SELECT ON api.latest_active_item_revisions TO anon;

/*
Many-to-many relationship of the same item going to different menus, and the same menu having different items.

--{{ menuItemMapping }}

*/
CREATE TABLE IF NOT EXISTS api.menu_item_mapping (
  menu_item_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  menu_id INT NOT NULL REFERENCES api.menus (menu_id) ON DELETE RESTRICT,
  item_id INT NOT NULL REFERENCES api.items (item_id) ON DELETE RESTRICT,
  absolute_position INT NOT NULL
  /* FIXME max number of items per menu */
);
/* TODO constraints - 5 for free, 15 for premium, 30 for gold, inf for platinum */
-- Nothing references this table, rows can be added & deleted freely per the chef's desire.

GRANT SELECT ON api.menu_item_mapping TO anon;

-- CREATE TABLE IF NOT EXISTS menu_item_ordering (
--   menu_id INT UNIQUE NOT NULL REFERENCES menus (menu_id) ON DELETE CASCADE,
--   menu_item_ids INT[] NOT NULL REFERENCES menu_item_mapping (menu_item_id) ON DELETE PRUNE -- wtf
-- );

-- TODO should I also get the latest version?
CREATE OR REPLACE FUNCTION api.get_menu_items(menu_id_ INT) RETURNS record AS
$$
  SELECT api.items.item_id, api.items.deleted_on, api.items.created_on
  AS item_id, deleted_on, created_on
    FROM api.menu_item_mapping
         INNER JOIN api.items
             ON api.menu_item_mapping.item_id = api.items.item_id
    WHERE api.menu_item_mapping.menu_id = menu_id_
    ORDER BY api.menu_item_mapping.absolute_position ASC;
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;

GRANT EXECUTE ON FUNCTION api.get_menu_items TO anon;
