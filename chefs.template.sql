CREATE TYPE subscription_type AS ENUM ('free', 'premium', 'gold', 'platinum');

/*
A chef is a Local Cooking user that we vet to have the power to create their own menus.

--{{ chefs }}

*/
CREATE TABLE IF NOT EXISTS chefs (
  user_id INT UNIQUE NOT NULL REFERENCES users (user_id) ON DELETE RESTRICT,
  chef_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  public_name VARCHAR ( 255 ) NOT NULL,
  profile VARCHAR ( 1024 ),
  enrolled_on TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
  revoked_on TIMESTAMPTZ, -- Pseudo-deletion
  subscription subscription_type NOT NULL,
  subscription_expiration TIMESTAMPTZ NOT NULL
  -- FIXME product delivery method
  -- TODO Payment method (same as user?)
  -- TODO chef rating?
);


CREATE OR REPLACE FUNCTION admin_enroll(user_id_ INT,
                                        public_name_ VARCHAR,
                                        subscription_ subscription_type,
                                        subscription_expiration_ TIMESTAMPTZ) RETURNS INT AS
$$
  INSERT INTO chefs (user_id, public_name, subscription, subscription_expiration)
  VALUES (user_id_, public_name_, subscription_, subscription_expiration_) RETURNING chef_id;
$$
  LANGUAGE SQL
  VOLATILE
  RETURNS NULL ON NULL INPUT;

CREATE OR REPLACE FUNCTION admin_disenroll(chef_id_ INT) RETURNS void AS
$$
BEGIN
  -- revoke chef
  UPDATE chefs SET revoked_on = CURRENT_TIMESTAMP WHERE chef_id = chef_id_;
  -- delete all the chef's items
  WITH chefs_items AS (
    SELECT items.item_id AS item_id
      FROM menu_item_mapping
          INNER JOIN menus
              ON menu_item_mapping.menu_id = menus.menu_id
          INNER JOIN items
              ON menu_item_mapping.item_id = items.item_id
      WHERE menus.chef_id = chef_id_
  )
  UPDATE items SET deleted_on = CURRENT_TIMESTAMP FROM chefs_items
  WHERE items.item_id = chefs_items.item_id;

END;
$$
  LANGUAGE plpgsql
  VOLATILE;

/*
At Local Cooking, we're going to grow our chef's credentials over time. Each new trend
will require new skills and certifications - for instance, being trained in gluten intolerance,
or peanut allergies, could be a specific trade. Furthermore, we may certify someone as a
vegan cook, which may grant them special interest. Likewise, in the future, chefs may issue
certifications of their own, which they use to vet other chefs and grow their academia.

--{{ credentials }}

*/
CREATE TABLE IF NOT EXISTS credentials (
  credential_id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title VARCHAR ( 255 ) NOT NULL,
  description VARCHAR ( 1024 ) NOT NULL
);

/*
Mapping between chefs and their credentials.

--{{ chefCredentials }}

*/
CREATE TABLE IF NOT EXISTS chef_credentials (
  chef_id INT NOT NULL REFERENCES chefs (chef_id) ON DELETE RESTRICT,
  credential_id INT NOT NULL REFERENCES credentials (credential_id) ON DELETE RESTRICT,
  UNIQUE (chef_id, credential_id) -- A chef can't have two of the same credential
);

-- TODO need to add creds, remove / delete them, and also menus, items, etc.

CREATE OR REPLACE FUNCTION get_chef_credentials(chef_id_ INT) RETURNS record AS
$$
  SELECT credentials.credential_id, credentials.title, credentials.description
  AS credential_id, title, description
    FROM chef_credentials
         INNER JOIN credentials
             ON chef_credentials.credential_id = credentials.credential_id
    WHERE chef_credentials.chef_id = chef_id_;
$$
  LANGUAGE SQL
  STABLE
  RETURNS NULL ON NULL INPUT;


CREATE OR REPLACE FUNCTION validate_chef_session(session_token_ uuid) RETURNS INT AS
$$
DECLARE
  user_id_ INT;
  chef_id_ INT;
BEGIN
  SELECT get_logged_in_user_id(session_token_) INTO user_id_;
  SELECT INTO chef_id_ chef_id FROM chefs WHERE user_id = user_id_; -- FIXME raise when not found?
  RETURN chef_id_;
END;
$$
  LANGUAGE plpgsql
  STABLE
  RETURNS NULL ON NULL INPUT;
